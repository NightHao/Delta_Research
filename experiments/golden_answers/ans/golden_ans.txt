Question: What is the system architecture of Vehicle-to-Grid?

Answer: ## 1. Overview
Vehicle-to-Grid (V2G) communication is organized according to the ISO/IEC OSI reference model, focusing on how data travels between an electric vehicle (EV) and the electrical grid. Within the context of ISO 15118, **[ISO-3]** specifies the Physical Layer (Layer 1) and Data Link Layer (Layer 2), including the V2G standardized service primitive interface, while **[ISO-2]** covers Layers 3 through 7. This part of ISO 15118 applies to both AC and DC use-cases unless stated otherwise.

## 2. Lower-Layer Requirements ([ISO-3])
- **Physical Layer (Layer 1) and Data Link Layer (Layer 2):**  
  - **[ISO-3]** provides detailed requirements for these lowest layers.  
  - Emphasizes a **large-scale separation** between the MAC sublayer and the physical layer.  
  - Aligns with the OSI model for open systems, ensuring consistent, standardized communication.

- **Hardware Control Path:**  
  - As noted in the information related to Figure 2, a hardware control path to the right of the communication stack handles **triggering and signaling** for [IEC-1]-related functionality.  
  - This path operates alongside the “communication related stack” in the middle and left sections of Figure 2.

## 3. Higher-Layer Requirements ([ISO-2])
- **Layers 3 to 7 (Network, Transport, Session, Presentation, Application):**  
  - **[ISO-2]** defines the upper layers for V2G communication, handling tasks such as network connectivity, message transport, session management, data presentation, and application-specific functions.

## 4. Figures
- **Figure 1 — Overview of [ISO-0] in the ISO/IEC OSI Reference Model**  
  Provides a broad look at the OSI layers and indicates how **[ISO-3]** fits within that structure for V2G purposes.

- **Figure 2 — [ISO-3] Relationship to the ISO/IEC OSI Reference Model**  
  Highlights the positioning of the Physical and Data Link layers (as defined by **[ISO-3]**) and illustrates the **separate hardware control path** for signaling and triggering means related to [IEC-1].  

## 5. Configuration Scope
- **AC and DC Use-Cases:**  
  - Unless otherwise specified, the **requirements in [ISO-3]** cover both alternating current (AC) and direct current (DC) charging, reflecting the broad applicability of these standards.

================================================================================

Question: What is HPGP?

Answer: ## 1. Overview
**HPGP** stands for **HomePlug Green PHY**, a specification mentioned in ISO 15118-3 for enabling power line communication between an Electric Vehicle Supply Equipment (EVSE) and an Electric Vehicle (EV). In the context provided, HPGP signals are injected into the control pilot line to support **bidirectional communication** within a Vehicle-to-Grid (V2G) setup.

## 2. Application in V2G Communication
- **Signal Injection on the Control Pilot Line**  
  - According to the referenced Annex A, HomePlug Green PHY signals are introduced onto the control pilot line to facilitate data exchange between one EVSE and one EV.  
  - While generally compliant with [HPGP], certain adaptations are made regarding **signal coupling**, **signal levels**, and **carrier usage** to accommodate the specifics of the control pilot circuit.

- **Dedicated Pair of Chips**  
  - A pair of HPGP chips (one in the EVSE and one in the EV) enables **bidirectional communication** over the control pilot line. This line typically handles the lower-frequency pilot signal (as per [IEC-1]), but it must also accommodate the higher-frequency HPGP signal.

- **Capacitive Considerations**  
  - The coupling circuit and component values—such as inductors and capacitors—are crucial for ensuring the HomePlug Green PHY signals do not overly attenuate or distort the control pilot function.  
  - The capacitive load of the EV, EVSE, and charge cord must be taken into account when injecting HPGP signals.

## 3. Table A.11 — Definition of Electrical Characteristics
**Table A.11** (labeled “Definition of electrical characteristics”) sets out the specific requirements for the physical signals. It covers parameters like cable length, inductance (L), damping resistor (RDamp), and the power spectral density (PSD) range for HPGP signals on the control pilot line. These specifications ensure that **HomePlug Green PHY** communication remains effective and within defined electrical limits.

> “Table A.11 gives requirements that physical signals shall comply with, in order to enable HomePlug Green PHY injection into the control pilot line, according to previous requirements.”

================================================================================

Question: What is SLAC?

Answer: ## 1. Overview
**SLAC** stands for **Signal Level Attenuation Characterization**, a protocol used to measure the signal strength between HomePlug Green PHY stations within a Vehicle-to-Grid (V2G) communication environment. Its primary role is to determine how strongly an Electric Vehicle (EV) and an Electric Vehicle Supply Equipment (EVSE) are connected via power line communication (PLC), enabling the system to identify and select the correct counterpart for data exchange.

## 2. Purpose and Function
- **Measuring Signal Strength**  
  SLAC is employed to **evaluate attenuation** and overall signal quality between the EV and the EVSE. By collecting and analyzing attenuation data over different frequency groups, the EV can ascertain which EVSE is directly connected.

- **Matching EV to EVSE**  
  During the “matching” process, the EV transmits measurement signals (M-Sounds), and the EVSE reports back its assessments of the incoming signal’s strength. Based on these reports, the EV decides whether a direct and reliable link to a specific EVSE is established.

- **Compliance with HomePlug Green PHY**  
  The signal strength measurement method is “the SLAC defined in the [HPGP].” SLAC messages (defined as MMEs, or Management Message Entries) follow the specifications outlined for power line communication in HomePlug Green PHY.

## 3. Process Flow and Figures
- **Signal Strength Measurement Sequence (Figure A.4)**  
  Though not detailed in the texts provided, this figure is mentioned as depicting the step-by-step process of signal strength measurement. SLAC underpins the procedure by collecting and reporting attenuation data.

- **SLAC Transmission Path Example (Figure A.11)**  
  Shows how the HomePlug Green PHY signals traverse through the EV, charge cord, and EVSE. SLAC-related calculations (such as attenuation and PSD—Power Spectral Density—levels) help confirm whether the communication link is suitable.

## 4. Relevant Tables
- **Table A.1 — Timing and Constant Values**  
  While the table primarily focuses on timings (like retries, toggles, and timeouts), it references overall matching processes that rely on SLAC to complete the EV–EVSE handshake.

In summary, SLAC is the **protocol** that measures and characterizes the **signal attenuation** between EV and EVSE, ensuring a reliable identification of the correct communication partner in V2G scenarios.

================================================================================

Question: What is Logical Network?

Answer: ## 1. Overview
A **logical network** is a set of low-layer communication stations sharing the same network key. It functions at **Layer 2** and ensures that only members within this network can exchange encrypted payload data and be visible to each other at higher layers.

## 2. Definition and Characteristics
- **Shared Network Key**: Stations in the logical network use a common key, allowing them to encrypt and decrypt payload data for secure communication.  
- **Layer 2 Scope**: According to Note 2, the logical network specifically resides at the Data Link Layer.  
- **Network Segmentation**: Multiple logical networks can exist simultaneously on the same physical media, isolating or segmenting traffic to prevent unauthorized cross-communication.

## 3. Joining and Leaving the Logical Network
- **Joining**: Figure A.7 (Sequence chart of joining the logical network) provides a visual guide for how an EV or EVSE enters the logical network. They typically exchange parameters and keys to align with the network’s encryption scheme.  
- **Leaving**: When a communication node leaves the logical network, it must do so within **TP_match_leave** (the maximum time defined in Table 3). At that point, parameters associated with the existing link are reset, and the node returns to an “Unmatched” status.

## 4. Timing Considerations (Table 3 — Timing and Constant Values)
Within **Table 3**, the parameter **TP_match_leave** sets the **maximum time** allowed for a node to exit the logical network. This ensures that the matching process and network membership transitions happen within a consistent and predictable timeframe for all participants.

================================================================================

Question: What is CCo?

Answer: ## 1. Overview
**CCo** stands for **Central Coordinator**, the manager of a HomePlug Green PHY (HPGP) network. It orchestrates network operations so that devices in the low-layer communication system can coordinate effectively.

## 2. Definition and Role
- **Central Coordinator**: A CCo governs the HPGP network, controlling essential aspects of data exchange.
- **HomePlug Green PHY Manager**: The CCo ensures that communication within the network is managed and regulated according to the HPGP standard.

## 3. Configuration Requirements
- **EVSE as CCo**:  
  - “[V2G3-A06-03] The low-layer communication module on the EVSE side shall be configured in order to always be the CCo.”  
  - This setting can be applied using the **APCM_SET_CCo.REQ** primitive from the [HPGP] specification’s “Control SAP Service.”  
- **EV Not Configured as CCo**:  
  - “[V2G3-A06-02] The low-layer communication module on the EV side shall be configured in order to never become the CCo.”

By assigning the CCo role exclusively to the EVSE, the system architecture ensures the EV manages communication from a subordinate position, with the EVSE coordinating network operations under HPGP.

================================================================================

Question: What is the difference between Data SAP and Data link control SAP?

Answer: ## 1. Overview
In the ISO 15118-3 standard, **Data SAP** (Data Service Access Point) and **Data Link Control SAP** (Data Link Control Service Access Point) are two distinct interfaces at Layer 2 that serve different purposes in the Vehicle-to-Grid (V2G) communication stack.

## 2. Data SAP
- **Definition**:  
  A **service access point** that defines the interface between Layer 2 and Layer 3 for the exchange of V2G-related payloads.  
- **Function**:  
  - Connects the data link layer (e.g., HomePlug Green PHY) to higher protocols such as IPv6.  
  - Often referred to as the **ETH SAP** because it provides an Ethernet II-class interface for network protocols.

## 3. Data Link Control SAP
- **Definition**:  
  A **service access point** that defines the interface between the connection coordination module and the low-layer communication technology for managing link status.  
- **Function**:  
  - Provides link status updates, error reporting, and control functions (e.g., setting link to “no link” or “link established”).  
  - It is used for coordinating activities such as terminating or pausing the data link.

## 4. Key Differences
1. **Purpose**  
   - **Data SAP**: Focused on **payload data exchange** between Layer 2 and Layer 3 (e.g., sending and receiving V2G messages over IPv6).  
   - **Data Link Control SAP**: Focused on **link management**, including link status, error notifications, and control primitives.

2. **Layer Interaction**  
   - **Data SAP**: An interface **to higher layers** (Layer 3 and above) for V2G communication payloads.  
   - **Data Link Control SAP**: An interface **between the connection coordination and lower-layer communication** to manage the operational state of the link.

By keeping these two interfaces separate, the standard cleanly distinguishes **data transmission** functions (Data SAP) from **link management** functions (Data Link Control SAP).

================================================================================

Question: What is the difference between basic signaling and high-level communication?

Answer: ## 1. Overview
“Basic signalling” and “high-level communication” (HLC) are two different layers of interaction between an Electric Vehicle (EV) and an Electric Vehicle Supply Equipment (EVSE). Both can coexist, but each serves a distinct purpose in the charging process.

## 2. Basic Signalling
- **Standard Reference**: [IEC-1]  
- **Key Characteristics**:  
  - It is always present, regardless of whether high-level communication exists.  
  - Relies on the control pilot signal to indicate EV-related information (via control pilot states) and EVSE-related information (via a Pulse Width Modulation (PWM) duty cycle).  
  - All timings comply with [IEC-1], Annex A.  
- **Scope**:  
  - Provides the fundamental, bidirectional exchange of charging status.  
  - Can be used alone for charging if no HLC is active or if HLC fails.

## 3. High-Level Communication (HLC)
- **Standard Reference**: [ISO-2]  
- **Key Characteristics**:  
  - Added on top of basic signalling, enabling a richer, bidirectional data exchange.  
  - Follows a structured sequence of data exchange:  
    1. **Data Link Setup**  
    2. **V2G Setup**  
    3. **V2G Charging Loop**  
  - Offers additional features not covered by basic signalling, such as dynamically adjusting certain charging parameters (without changing the PWM duty cycle during normal operation).  
- **Scope**:  
  - Enhances the charging session by providing advanced communication (e.g., advanced grid information, billing, and authentication) alongside the core pilot signals.  
  - Dependent on the data link layer specified in [ISO-2].

## 4. Primary Differences
- **Signalling Method**  
  - **Basic Signalling**: Uses control pilot states and duty cycle (PWM) to relay essential start/stop and current-limit signals in compliance with [IEC-1].  
  - **High-Level Communication**: Uses structured protocols (as per [ISO-2]) for more complex interactions such as authentication, tariff negotiation, and real-time information exchange.

- **Use Case**  
  - **Basic Signalling**: Mandatory baseline for safety and basic charge management; always active, even if high-level communication is absent.  
  - **High-Level Communication**: Optional but adds advanced capabilities (e.g., bidirectional communication features beyond simple pilot signalling).

- **Timings and Protocol**  
  - **Basic Signalling**: Must follow [IEC-1] timing specifications.  
  - **High-Level Communication**: Uses the sequence defined in [ISO-2], which extends beyond basic timing constraints to manage more complex data flows.

================================================================================

Question: What is the difference between MTC and PTC?

Answer: ## 1. Overview  
In ISO 15118‑5 conformance tests, **MTC** (Main Test Component) and **PTC** (Parallel Test Component) are two types of test components used within a TTCN‑3 environment. They serve different roles in constructing and running test scenarios against a System Under Test (SUT).

## 2. Main Test Component (MTC)
- **Definition**  
  - A single, central test component responsible for controlling and coordinating the entire test process.  
  - Referred to as **MTC** in abbreviated form.  
- **Key Functions**  
  1. **Creates and Controls PTCs**: The MTC spawns parallel test components and orchestrates their behavior.  
  2. **Computes and Assigns Test Verdicts**: It evaluates the test results and determines pass/fail (or other verdicts) for the test case.  
  3. **Delimits the Lifeline**: The MTC typically holds the overall test configuration, managing timers, variables, and constants for the duration of test execution.  
- **Implementation Notes**  
  - If the SUT is a **SECC**, the MTC uses the type **SECC_Tester**.  
  - If the SUT is an **EVCC**, the MTC uses the type **EVCC_Tester**.

## 3. Parallel Test Component (PTC)
- **Definition**  
  - A **secondary** test component created by the MTC to observe or handle specific parts of the test.  
- **Key Functions**  
  1. **Observes Specific Signals or Protocols**: For instance, the PTC called **HAL_61851_Listener** continuously checks IEC 61851 parameters (voltage, frequency, duty cycle, etc.).  
  2. **Supports Main Tests**: It communicates with the MTC (often through dedicated ports) to report conditions or trigger events within the test scenario.  
- **Implementation Notes**  
  - Each PTC focuses on a **specialized** testing task (e.g., verifying PWM behavior), while the MTC retains overall control and verdict assignment.

## 4. Primary Differences
1. **Role in the Test Architecture**  
   - **MTC**: The **master** component orchestrating the test flow and verdicts.  
   - **PTC**: A **helper** component performing parallel tasks (e.g., monitoring signals).

2. **Creation and Control**  
   - **MTC**: Exists as a **single** primary component, responsible for setting up and managing the test environment.  
   - **PTC**: **Spawned** by the MTC, often dedicated to monitoring or specialized operations.

3. **Verdict and Coordination**  
   - **MTC**: Final authority for test verdicts; controls the entire test configuration lifecycle.  
   - **PTC**: Reports observations to the MTC but does not assign a test verdict.

Through this division of responsibilities, the conformance tests can be structured in a modular, maintainable way, with the MTC coordinating the overall procedure while delegating specific monitoring or event-handling tasks to one or more PTCs.

================================================================================

Question: What is ATS?

Answer: ## 1. Overview
**ATS** stands for **Abstract Test Suite**. As defined in ISO 15118‑5, it is a collection of **abstract test cases** used to verify whether a System Under Test (SUT) meets specific requirements and behaves according to the ISO 15118‑3 conformance criteria for physical and data link layers.

## 2. ATS Purpose and Coverage
- **Conformance Verification**:  
  The ATS checks observable capabilities (static conformance) and dynamic behavior (behavioral conformance) of the SUT against ISO 15118‑3.  
- **Black Box Testing**:  
  Tests are conducted without internal knowledge of the SUT’s implementation, focusing solely on inputs, outputs, and observable events.  
- **Scope Definition**:  
  - Requirements in ISO 15118‑3 may be deemed **out of scope**, **not testable**, or **only partially testable** within the ATS (Tables 27, 28).  
  - Coverage details, including which test cases address each requirement, are summarized in dedicated tables (e.g., Table 29).  
  - Some requirements are tested **indirectly** (marked as "I") or covered **partially** (marked as "P") due to the nature of black box testing constraints.

## 3. ATS Structure
- **Abstract Test Cases**:  
  Each test case describes the inputs, expected outputs, and pass/fail conditions **abstractly**, meaning they do not tie to a specific hardware or software implementation.
- **Capability Tests**:  
  Ensure the SUT’s implemented features align with **static conformance** requirements in ISO 15118‑3.
- **Behavior Tests**:  
  Examine the SUT’s **dynamic** responses in different scenarios, as thoroughly as practical, to confirm compliance with **dynamic conformance** requirements.

## 4. Relationship to the SUT
- The SUT can be an **Electric Vehicle Communication Controller (EVCC)** or a **Supply Equipment Communication Controller (SECC)** implementing the physical and data link layers of ISO 15118‑3.  
- The ATS uses **abstract test scenarios** to interact with the SUT, observing whether it behaves according to normative requirements (e.g., message formats, timing, signal checks).

## 5. Test Suite Conventions
- **Tables for Coverage**:  
  - **Table 27 and Table 28** list requirements that are out of scope or tested indirectly.  
  - **Table 29** provides a mapping of each ISO 15118‑3 requirement to how it is addressed (fully, partially, or indirectly) by the ATS.  
- **Symbols** (X, I, P, N, etc.) indicate whether a requirement is fully covered, indirectly covered, partially covered, not testable, out of scope, etc.

This ATS (Abstract Test Suite) framework increases confidence that different EVCC/SECC implementations interoperate correctly at the physical and data link layers of ISO 15118‑3, even though it cannot guarantee absolute conformance or performance under all conditions.

================================================================================

Question: What is TSS?

Answer: ## 1. Overview
In ISO 15118‑5, **TSS** stands for **Test Suite Structure**, referring to how conformance test cases are organized and grouped. The TSS ensures that all necessary scenarios and requirements are covered in a structured manner when testing a System Under Test (SUT), such as an Electric Vehicle Communication Controller (EVCC) or a Supply Equipment Communication Controller (SECC).

## 2. Purpose and Composition
1. **Complete Set of Test Cases**  
   The TSS encompasses all relevant test cases needed to verify conformance with ISO 15118‑3’s physical and data link layer requirements. These test cases may be grouped by use cases (e.g., AC vs. DC charging) or modules representing different functional domains.

2. **Hierarchical Groupings**  
   - **Test Cases** form the second hierarchical level, each specifying how the SUT is to be stimulated and how responses are assessed.  
   - **Pre- and Post-Conditions** as well as actual “test behaviors” are encapsulated in functions, which belong to the lowest abstract level of the TSS.  
   - Annexes within the standard (e.g., Annex A for configuration, Annex B for control parts, Annex C for test cases) further subdivide the overall structure.

## 3. How the TSS Organizes Testing
- **Test Cases**: Each test case includes pre-conditions, the test scenario itself (test behavior), and any post-conditions needed after execution.  
- **Domain Subgroups**: Requirements may be segmented by domain (e.g., AC or DC) or other categories (e.g., “CMN” for common behaviors).  
- **Annex References**:  
  1. **Annex A** – Configuration (timers, PICS, PIXIT)  
  2. **Annex B** – Control Parts (test group sequences)  
  3. **Annex C** – Actual Test Cases  
  4. **Annex D / E** – Functions for pre-/post-conditions and test behaviors  
  5. **Annex F** – TTCN‑3 Templates  
  6. **Annex G** – Data Structures  

By using this structured approach, the TSS ensures clarity about which test cases must be run, how they interrelate, and how the entire suite of tests covers all necessary aspects of conformance for a particular SUT.

================================================================================

Question: What is EIM?

Answer: ## 1. Overview
**EIM** stands for **External Identification Means**. It is an approach for identifying or authenticating the user (e.g., a driver) at an Electric Vehicle Supply Equipment (EVSE), typically separate from the automated Plug and Charge (PnC) mechanism.

## 2. Related Context
The ISO 15118‑3 standard specifies two main authentication methods when an EV is plugged in at an EVSE:
1. **Plug and Charge (PnC)**: Uses automated certificates or credentials stored within the vehicle.  
2. **External Identification Means (EIM)**: Uses an external process (e.g., RFID card, keypad entry, or other means) for authentication and authorization.

### EIM With or Without BC
- **EIM with BC**: EIM can be combined with **Basic Charging (BC)** as defined in IEC 61851‑1.  
- **EIM without BC**: EIM may be used without falling back to IEC 61851‑1’s basic mode.

Table 1 (below) summarizes different EIM and/or PnC implementations on an EVSE:

**Table 1 — EIM and/or PnC in EVSEs** (Excerpt)
```
-----------------------------------------------------------------------------------
         |  Figure no. | Description                                 | PnC | EIM w. BC | EIM w/o BC | ...
-----------------------------------------------------------------------------------
AC EVSE  |  Figure 3   | Seq1. Matching not started (start with 5 %) | a)  | b)       | c)         | ...
         |  Figure 4   | Seq2. Matching not started (start with X1)  | a)  | b)       | c)         | ...
         |  Figure 5   | Seq3. Matching started (start with 5 %)     | a)  | b)       | c)         | ...
         |  Figure 6   | Seq4. Matching started (start with X1)      | a)  | b)       | c)         | ...
         |  Figure 7   | Seq5. EIM before plug-in                     | -   | b)       | c)         | ...
DC EVSE  |  Figure 8   | Seq6.                                        | a)  | -        | c)         | ...
-----------------------------------------------------------------------------------
```

## 3. Usage in Connection Coordination
Figures 3–8 in ISO 15118‑3 illustrate various scenarios where an EVSE can support PnC and/or EIM:
- **AC EVSE** can offer both PnC and EIM or only one of them, allowing for different branching in the connection coordination sequence.
- **DC EVSE** similarly can support PnC and EIM, with the vehicle plugging in and then selecting the authentication method.

When EIM is used:
- The EVSE typically waits for the driver’s external action (e.g., tapping a card or entering credentials).
- If EIM completes successfully, the EVSE may either begin basic charging (BC) or proceed with high-level communication (HLC), depending on whether PnC is also implemented.

## 4. Illustrative Figures
- **Figure 3 / Figure 4**: Show AC EVSE sequences starting with 5 % or X1 pilot duty cycle. Branches labeled b) and c) depict EIM scenarios (with or without BC).  
- **Figure 5 / Figure 6**: Show matching started before EIM completes.  
- **Figure 7**: Demonstrates EIM done before the vehicle is even plugged in.  
- **Figure 8**: Depicts a DC EVSE handling PnC and EIM in different branches.

## 5. Key Takeaways
1. **Definition**: EIM is an alternative to Plug and Charge, allowing external (often manual) user identification or authorization.  
2. **Flexibility**: An EVSE might implement EIM in addition to or instead of PnC.  
3. **Integration**: EIM can tie into basic IEC 61851‑1 functionality (BC) or run alongside higher-level communication (HLC).  
4. **Relevance to Control Pilot**: The EVSE’s control pilot states (like 5 %, X1, etc.) can be tailored to allow a driver time to complete EIM before starting or resuming matching and charging.

In summary, **EIM (External Identification Means)** is a user-authentication process external to automated PnC, providing an alternative or additional route for verifying the EV driver before charging begins.

================================================================================

Question: What is CM_SLAC_PARM.REQ?

Answer: ## 1. Overview
**CM_SLAC_PARM.REQ** is a broadcast message used by the Electric Vehicle (EV) to announce the parameters that will be used during the “signal strength measurement” (SLAC) process, specifically before starting the matching procedure between the EV and an unmatched EVSE. Once the EV broadcasts this message, any unmatched EVSE that detects the correct control pilot state (indicating an EV is connected) and is ready to participate in SLAC will respond with a **CM_SLAC_PARM.CNF** message.

## 2. Purpose and Context
1. **Signal Strength Measurement (SLAC):**  
   - SLAC (Signal Level Attenuation Characterization) is part of the matching process in which the EV and EVSE determine the best communication link by measuring signal attenuation on the pilot wire.
   - Before actual signal strength measurements and M-Sound transmissions take place, both the EV and EVSE need consistent parameters (e.g., the number of M-Sounds, the timeouts, run identifiers).  
   - **CM_SLAC_PARM.REQ** allows the EV to distribute these parameters.

2. **Matching Process Initiation:**
   - The matching process typically begins soon after the EV is plugged in.  
   - The EV’s low-layer communication module sends **CM_SLAC_PARM.REQ** as a broadcast.  
   - Any EVSE still in an “Unmatched” state, upon receiving **CM_SLAC_PARM.REQ**, can prepare to respond with **CM_SLAC_PARM.CNF**.

3. **Timing Considerations:**
   - This request may be sent immediately after cable plug-in, although the EVSE might still be “booting” its communication module.  
   - In that case, the initial **CM_SLAC_PARM.REQ** could go unanswered if the EVSE is not yet fully ready.  
   - Once the EVSE communication module is awake, it replies with **CM_SLAC_PARM.CNF**.

## 3. Structure and Fields
From *Table A.2 — Involved MMEs for parameters exchange*, the **CM_SLAC_PARM.REQ** message includes:

- **APPLICATION_TYPE** (fixed value 0x00)  
  Indicates “PEV–EVSE matching.”
- **SECURITY_TYPE** (fixed value 0x00)  
  Indicates “No Security.”
- **RunID** (8 octets)  
  A random identifier chosen by the EV for that SLAC session. It remains constant for all subsequent messages of the same run (e.g., the EVSE uses the same RunID in **CM_SLAC_PARM.CNF**).

Being a broadcast message, **CM_SLAC_PARM.REQ** is visible to any unmatched EVSE on the same physical link. Only EVSEs which detect a valid control pilot state (i.e., that an EV is actually plugged in) will respond.

## 4. Usage in the Matching Sequence
1. **Broadcast by the EV:**  
   - Sent from the EV side as soon as the cable is plugged in (or as soon as the EV communication module is ready).
2. **EVSEs Respond with CM_SLAC_PARM.CNF:**  
   - Any unmatched EVSE receiving **CM_SLAC_PARM.REQ** sends back **CM_SLAC_PARM.CNF** unicast to the EV.  
   - The EVSE includes parameters such as *NUM_SOUNDS* or the *Time_Out* field needed for the subsequent M-Sound transmissions.
3. **Subsequent Steps:**  
   - Once the EV has the EVSE’s confirmation and both sides agree on parameters, the “signal strength measurement” is carried out (i.e., M-Sound transmissions), eventually leading to a final decision on whether the EV is connected directly to this responding EVSE.

## 5. Key Points
- **CM_SLAC_PARM.REQ** is fundamental to initiating the matching process, ensuring both sides know how many M-Sounds to send, timing constraints, and run identifiers.  
- The broadcast nature of **CM_SLAC_PARM.REQ** lets multiple EVSEs see the request, but only those in the “Unmatched” state with a valid control pilot will respond.  
- If an EVSE is not yet active (e.g., still booting) at the time the EV sends **CM_SLAC_PARM.REQ**, no response is received. The EV may retry or wait for the EVSE module to become active.

In summary, **CM_SLAC_PARM.REQ** is the EV’s broadcast request used to distribute SLAC measurement parameters so that any suitable, unmatched EVSE can reply and proceed toward completing the matching process.

================================================================================

Question: What is CM_SLAC_PARM.CNF?

Answer: ## 1. Overview
**CM_SLAC_PARM.CNF** is a unicast response message sent from an unmatched EVSE to an EV after receiving the broadcast **CM_SLAC_PARM.REQ**. It provides key parameters (such as how many M-Sounds to expect, the RunID identifier, and other SLAC‐related fields) that the EV needs for the upcoming signal strength measurement phase in the matching process.

## 2. Background and Purpose
1. **Signal Strength Measurement (SLAC) Context:**
   - SLAC (Signal Level Attenuation Characterization) is performed so that the EV and EVSE can measure the quality of their communication channel along the control pilot line and determine whether they are directly connected.
   - The **CM_SLAC_PARM.CNF** message is essential for confirming that the EVSE is ready to take part in this process and for conveying specific SLAC parameters back to the EV.

2. **Role in Matching Process:**
   - When an EV decides to initiate the matching process, it first broadcasts **CM_SLAC_PARM.REQ**.
   - Any EVSE in an “Unmatched” state (i.e., not currently matched with another EV) and detecting a valid control pilot (indicating a physical EV connection) can respond with **CM_SLAC_PARM.CNF**.
   - This CNF message includes details on M-Sound transmissions, the timeouts involved, and the unique RunID assigned by the EV in the original request.

## 3. Structure and Fields
Based on *Table A.2 — Involved MMEs for parameters exchange*, the **CM_SLAC_PARM.CNF** message fields include:

- **M-SOUND_TARGET** (0 to 5 octets; fixed to `0xFFFFFFFFFFFF`)  
  Indicates that M-Sound signals shall be sent as an Ethernet broadcast.
- **NUM_SOUNDS** (1 octet)  
  Reflects the number of M-Sound transmissions the EV will make (defined by `C_EV_match_MNBC` from the specification).
- **Time_Out** (1 octet, `0x06`)  
  Corresponds to `TT_EVSE_match_MNBC`, specifying how long the EVSE will wait to receive those M-Sounds from the EV after sending its response.
- **RESP_TYPE** (1 octet, `0x01`)  
  A fixed value denoting “Other GP station.”
- **FORWARDING_STA** (6 octets)  
  The EV Host’s MAC address. This field ensures all results are directed back to the EV host.
- **APPLICATION_TYPE** (1 octet, `0x00`)  
  Indicates “PEV–EVSE Matching.”
- **SECURITY_TYPE** (1 octet, `0x00`)  
  Indicates “No Security.”
- **RunID** (8 octets)  
  Must match the `RunID` used in the original **CM_SLAC_PARM.REQ**, ensuring the EV recognizes this CNF as belonging to the same SLAC session.

## 4. Behavior and Requirements
1. **Unicast Response:**
   - While **CM_SLAC_PARM.REQ** is broadcast by the EV, the **CM_SLAC_PARM.CNF** is sent unicast from the EVSE specifically back to the requesting EV (using the EV MAC address as the destination).

2. **Timeout and Retries:**
   - After the EV sends **CM_SLAC_PARM.REQ**, it waits up to `TT_match_response` for at least one **CM_SLAC_PARM.CNF**.
   - If no valid CNF arrives within that time, the EV may retry sending **CM_SLAC_PARM.REQ** (up to `C_EV_match_retry` times). Should all retries fail, the matching process is considered **FAILED**.
   - If the EV receives a **CM_SLAC_PARM.CNF** but its content is invalid (e.g., deviates from the format in *Table A.2*), the EV ignores it.

3. **EVSE Prerequisites:**
   - An EVSE only sends **CM_SLAC_PARM.CNF** if:
     - It detects a valid control pilot (i.e., an EV is physically connected).
     - It is in the “Unmatched” state.

## 5. Example of Usage (Error Handling)
- *Figure A.9* shows a scenario where the EV sends **CM_SLAC_PARM.REQ** immediately after plugging in. If the EVSE is still booting and does not respond, the EV times out. Once the EVSE finishes booting, it can respond with **CM_SLAC_PARM.CNF** to confirm participation in SLAC.

---

By providing these parameters (e.g., number of M-Sounds, timeouts, RunID), **CM_SLAC_PARM.CNF** finalizes the initial step of parameter negotiation, enabling both the EV and EVSE to proceed with the signal strength measurement (SLAC) phase for the matching process.

================================================================================

Question: What is CM_START_ATTEN_CHAR.IND?

Answer: ## 1. Overview
**CM_START_ATTEN_CHAR.IND** is a broadcast message used during the signal strength measurement phase of the EV–EVSE (Electric Vehicle – Electric Vehicle Supply Equipment) matching process. Once the EV and EVSE have exchanged initial parameters, the EV initiates the attenuation characterization by sending this message **C_EV_start_atten_char_inds** times. These transmissions are followed by the sending of multiple M-SOUNDS, allowing the EVSE(s) to measure the signal’s attenuation across different frequency groups and return the results to the EV.

## 2. Purpose and Role in Signal Strength Measurement
1. **Initiation of Attenuation Measurement**:  
   After successfully exchanging parameters (using messages like **CM_SLAC_PARM.REQ** and **CM_SLAC_PARM.CNF**), the EV uses **CM_START_ATTEN_CHAR.IND** to announce to all potential EVSEs that it will broadcast a certain number of M-SOUNDS.  
2. **Multiple Transmissions**:  
   The EV sends **CM_START_ATTEN_CHAR.IND** a specified number of times, defined by **C_EV_start_atten_char_inds** (see Table A.1 references). This repeated indication ensures that all listening EVSEs properly prepare to receive and measure the upcoming M-SOUNDS.  
3. **Broadcast Nature**:  
   **CM_START_ATTEN_CHAR.IND** is broadcast to allow every unmatched EVSE on the network to detect and measure the signals if it sees a valid control pilot line.  
4. **Followed by M-SOUNDS**:  
   Right after sending the indicated number of **CM_START_ATTEN_CHAR.IND** messages, the EV proceeds with **C_EV_match_MNBC** M-SOUNDS. EVSEs then measure the signal attenuation from these M-SOUNDS and respond back to the EV via **CM_ATTEN_CHAR.IND** messages.

## 3. Message Fields and Structure
Per *Table A.4 — MMEs parameters definition for SLAC*, **CM_START_ATTEN_CHAR.IND** includes the following key fields:

- **APPLICATION_TYPE** (octet 0, value 0x00):  
  Indicates “PEV–EVSE Matching.”
- **SECURITY_TYPE** (octet 1, value 0x00):  
  Indicates “No Security.”
- **NUM_SOUNDS** (octet 2, value = C_EV_match_MNBC):  
  Number of M-Sounds to be sent by the EV after this indication message.
- **Time_Out** (octet 3, value = TT_EVSE_match_MNBC):  
  A maximum time window for the M-Sounds transmission.
- **RESP_TYPE** (octet 4, value 0x01):  
  Indicates “other Green PHY station.”
- **FORWARDING_STA** (octets 5–10, EV host MAC address):  
  Ensures the EV is the ultimate target for the SLAC results.
- **RunID** (octets 11–18):  
  Matches the `RunID` from the preceding **CM_SLAC_PARM.REQ**, linking all messages in this matching run.

## 4. Related Procedures and Timings
1. **C_EV_start_atten_char_inds**:  
   Defines how many times **CM_START_ATTEN_CHAR.IND** is transmitted (specified in *Table A.1*).  
2. **TP_EV_batch_msg_interval**:  
   The interval between consecutive **CM_START_ATTEN_CHAR.IND** messages (and/or **CM_MNBC_SOUND.IND** messages).  
3. **TT_EV_atten_results**:  
   Once the EV has sent all **CM_START_ATTEN_CHAR.IND** messages and the subsequent M-SOUNDS, it waits for the EVSE’s attenuation report (via **CM_ATTEN_CHAR.IND**) within this timeout.

## 5. Summary of the Workflow
1. **Parameter Exchange**:  
   - The EV sends **CM_SLAC_PARM.REQ** (broadcast).  
   - The EVSE responds with **CM_SLAC_PARM.CNF** (unicast).
2. **Attenuation Start**:  
   - The EV sends **CM_START_ATTEN_CHAR.IND** C_EV_start_atten_char_inds times to broadcast that it will now send M-SOUNDS.
3. **M-Sound Transmission**:  
   - The EV sends C_EV_match_MNBC M-SOUNDS so that listening EVSEs can gauge signal strength.
4. **EVSE Attenuation Reporting**:  
   - Each EVSE returns its measurement in a **CM_ATTEN_CHAR.IND**.  
   - The EV acknowledges with **CM_ATTEN_CHAR.RSP** for each received measurement result.

Through this procedure, **CM_START_ATTEN_CHAR.IND** initiates the actual measurement sequence, ensuring that every relevant EVSE is aware and ready to process the M-SOUNDS for the upcoming signal strength analysis.

================================================================================

Question: What is CM_MNBC_SOUND.IND?

Answer: ## 1. Overview
**CM_MNBC_SOUND.IND** is a broadcast message containing so-called “M-Sounds,” used during the EV–EVSE (Electric Vehicle – Electric Vehicle Supply Equipment) signal strength measurement process. After the EV has indicated the start of attenuation characterization, it sends a predefined number of **M-SOUNDS** (each transmitted as **CM_MNBC_SOUND.IND**). EVSEs listen to these broadcast messages to measure the signal’s attenuation across various frequency groups.

## 2. Purpose and Role in Signal Strength Measurement
1. **M-Sound Broadcast**  
   The EV transmits **C_EV_match_MNBC** M-Sounds, each sent as a **CM_MNBC_SOUND.IND** broadcast. These transmissions allow every listening EVSE to evaluate how strong (or attenuated) the EV’s signal is.
2. **Attenuation Calculation at EVSE**  
   Each EVSE uses the content of the **M-SOUNDS** to determine the attenuation values, later reported to the EV by way of **CM_ATTEN_CHAR.IND**.
3. **Sequential Process**  
   - **CM_START_ATTEN_CHAR.IND** messages indicate the start of the measurement phase.  
   - **CM_MNBC_SOUND.IND** messages (the M-SOUNDS) follow.  
   - EVSEs measure the signal from these broadcast frames and reply to the EV with signal strength results.

## 3. Key Fields from Table A.4
As specified in *Table A.4 (continued)* for “CM_MNBC_SOUND.IND broadcast,” the main fields include:

- **APPLICATION_TYPE** (octet 0, fixed 0x00):  
  Indicates “PEV–EVSE Matching.”
- **SECURITY_TYPE** (octet 1, fixed 0x00):  
  Indicates “No Security.”
- **SenderID** (octets 2–18, total 17 octets):  
  Typically set to 0x00 in the reference table.
- **Cnt** (octet 19):  
  A countdown showing the remaining M-SOUNDS after the current message.
- **RunID** (octets 20–27):  
  Matches the `RunID` from the parameter exchange phase, keeping all messages in the same “run.”
- **RSVD** (octets 28–35, reserved, set to 0x00).
- **Rnd** (octets 36–51):  
  A random value used in the matching process.

## 4. Relationship to Other Messages
1. **CM_START_ATTEN_CHAR.IND**  
   Sent before the M-SOUNDS to announce that the EV will broadcast them.
2. **CM_MNBC_SOUND.IND**  
   Delivers each M-Sound as a broadcast, repeated **C_EV_match_MNBC** times.
3. **CM_ATTEN_CHAR.IND**  
   The EVSE’s response to the EV with measured attenuation data after receiving M-SOUNDS.
4. **CM_ATTEN_CHAR.RSP**  
   The EV’s acknowledgment of each EVSE’s attenuation report.

## 5. Timings and Parameters
- **C_EV_match_MNBC**:  
  Defines how many M-SOUNDS (i.e., **CM_MNBC_SOUND.IND** messages) the EV sends.  
- **TP_EV_batch_msg_interval**:  
  Defines the interval between consecutive **CM_MNBC_SOUND.IND** (or **CM_START_ATTEN_CHAR.IND**) transmissions.

In summary, **CM_MNBC_SOUND.IND** is the broadcast mechanism by which the EV repeatedly sends M-Sounds, allowing EVSEs to measure and report how strongly the EV’s signal is received. This process is crucial for the EV to identify which EVSE is directly connected based on the measured attenuation.

================================================================================

Question: What is CM_ATTEN_CHAR.IND?

Answer: ## 1. Overview
**CM_ATTEN_CHAR.IND** is a unicast message that EVSEs send to the EV during the **signal strength measurement** phase. It conveys an **attenuation profile** (calculated by the EVSE) so the EV can determine which EVSE is physically connected in a direct way. This message and its content guide the EV’s matching decision—whether an EVSE is definitely found, potentially found, or not found.

## 2. Purpose and Role in Signal Strength Measurement
1. **Measurement Response**  
   After the EV broadcasts M-SOUNDS (via **CM_MNBC_SOUND.IND**), each EVSE measures the signal attenuation across different frequency groups. They then compile these results and respond to the EV with **CM_ATTEN_CHAR.IND**.
2. **Attenuation Profile**  
   The message carries the field **ATTEN_PROFILE**, which represents the averaged signal attenuation from the EV. The EVSE obtains this profile by:
   - Receiving multiple M-SOUNDS from the EV.
   - Averaging their measured values (and possibly applying corrections, as described in the standard).
3. **EV Matching Decision**  
   The EV processes the incoming **CM_ATTEN_CHAR.IND** messages from all potential EVSEs. Based on the reported average attenuation values, the EV sets its **EV_Discovering_Status** to:
   - **EVSE_FOUND**: the EVSE is definitively identified (attenuation under a direct threshold).
   - **EVSE_POTENTIALLY_FOUND**: more than one candidate remains, requiring further steps.
   - **EVSE_NOT_FOUND**: no valid direct EVSE identified.

## 3. Content and Calculation Details
- **ATTEN_PROFILE**:  
  The EVSE calculates the **ATTEN_PROFILE** by averaging the signal strength data from all received M-SOUNDS. Each **CM_ATTEN_CHAR.IND** includes a single attenuation profile for the EV.
- **Average_Attenuation**:  
  This overall average is the arithmetic (or possibly weighted) mean of all groups in the profile. The result helps the EV confirm or rule out direct EVSE connections.

## 4. EV Side Handling
1. **Response and Filtering**  
   - Each **CM_ATTEN_CHAR.IND** is acknowledged by **CM_ATTEN_CHAR.RSP** from the EV.  
   - If `NUM_SOUNDS` is zero or the content is invalid, the EV ignores the entire **CM_ATTEN_CHAR.IND**.  
   - Even if the EVSE did not send a prior **CM_SLAC_PARM.CNF**, the EV still processes any valid **CM_ATTEN_CHAR.IND** it receives.
2. **Timer TT_EV_atten_results**  
   - Starts when the EV sends the first **CM_START_ATTEN_CHAR.IND**.  
   - The EV collects **CM_ATTEN_CHAR.IND** messages until this timer expires or all anticipated EVSE responses arrive.

## 5. EVSE Side Handling
1. **Generation of CM_ATTEN_CHAR.IND**  
   - The EVSE listens to M-SOUNDS, computes the averaged attenuation within **TP_EVSE_avg_atten_calc** after the last M-Sound or timer expiration, and sends **CM_ATTEN_CHAR.IND** to the EV.  
   - Upon sending **CM_ATTEN_CHAR.IND**, the EVSE starts **TT_match_response**, expecting **CM_ATTEN_CHAR.RSP** from the EV.
2. **Retries**  
   - If **CM_ATTEN_CHAR.RSP** is not received within **TT_match_response**, the EVSE retransmits **CM_ATTEN_CHAR.IND**. After **C_EV_match_retry** attempts without acknowledgment, matching is deemed **FAILED**.

## 6. Relationship to EV Discovery Status
Following the final receipt of a **CM_ATTEN_CHAR.IND**, the EV uses the average attenuation reported to classify the EVSE. According to Table A.3:
- If attenuation is below a direct threshold, **EVSE_FOUND**.
- If it is in an intermediate range, **EVSE_POTENTIALLY_FOUND**.
- If it is above the indirect threshold, **EVSE_NOT_FOUND**.

In this way, **CM_ATTEN_CHAR.IND** is a pivotal message enabling the EV to decide which EVSE it is connected to based on signal strength measurements.

================================================================================

Question: What is CM_ATTEN_CHAR.RSP?

Answer: ## 1. Overview
**CM_ATTEN_CHAR.RSP** is a unicast message sent by the **EV** in response to a **CM_ATTEN_CHAR.IND** message from the EVSE. After the EVSE sends its measured signal attenuation data (via CM_ATTEN_CHAR.IND), the EV confirms reception by sending CM_ATTEN_CHAR.RSP. This acknowledgment is part of the **signal strength measurement** phase, ensuring the EVSE knows the EV has processed the attenuation information.

## 2. Purpose and Sequence
1. **Signal Strength Response Confirmation**  
   - Once the EV receives **CM_ATTEN_CHAR.IND**, it sends **CM_ATTEN_CHAR.RSP** to confirm successful reception of the attenuation profile.
   - This exchange is integral to completing the attenuation measurement loop.

2. **Error Handling (EVSE Side)**  
   - If the EVSE receives a **CM_ATTEN_CHAR.RSP** that contains invalid content (i.e., deviates from the defined parameters), the EVSE ignores it.
   - The specifics of what constitutes “invalid content” are tied to the MME definition in Table A.4, although the details of that table are not shown here.

## 3. Role in the Matching Process
1. **Closes the Attenuation Measurement Step**  
   - Each CM_ATTEN_CHAR.IND from the EVSE is individually answered by a CM_ATTEN_CHAR.RSP from the EV. This confirms that the EV has collected the signal strength information.
2. **Triggers Next Actions**  
   - Once the EV has acknowledged all necessary EVSE attenuation data, it can proceed to the subsequent steps (e.g., deciding if the EVSE is found, potentially found, or not found).

## 4. Key Considerations
- **Uniquely Sent Per IND**: For every CM_ATTEN_CHAR.IND message, there is exactly one CM_ATTEN_CHAR.RSP.  
- **Required for Proper Sequence**: Without the EV’s RSP, the EVSE may not consider the measurement phase complete.  
- **Invalid Content Handling**: If the RSP is malformed or outside the expected definitions, the EVSE discards it, potentially causing the matching process to fail.

This message thus ensures that the EVSE has explicit confirmation of the EV’s receipt of attenuation measurements, helping maintain a reliable communication loop during the SLAC-based signal strength measurement phase.

================================================================================

Question: What is CM_ATTEN_PROFILE.IND?

Answer: ## 1. Overview
**CM_ATTEN_PROFILE.IND** is a message used in the SLAC-based signal strength measurement procedure to convey per‐carrier‐group attenuation data measured by the EVSE. This information is later used to generate the averaged or “corrected” attenuation profile reported in **CM_ATTEN_CHAR.IND**.

## 2. Role in the Signal Strength Measurement
1. **Collection of Individual Measurements**  
   - During the SLAC process, the EVSE measures the attenuation of each M-SOUND it receives.  
   - These measurements are captured in **CM_ATTEN_PROFILE.IND** messages (one or more, depending on the implementation).

2. **Basis for Aggregation in CM_ATTEN_CHAR.IND**  
   - The final **CM_ATTEN_CHAR.IND** message, which the EVSE sends to the EV, uses the attenuation data from **CM_ATTEN_PROFILE.IND** messages.  
   - Specifically, the EVSE calculates the arithmetic mean of the attenuation profiles from multiple M-SOUNDS (and applies an AttnRxEVSE correction) to produce the overall ATTEN_PROFILE reported in **CM_ATTEN_CHAR.IND**.

## 3. Attenuation Correction
- **AttnRxEVSE Adjustment**  
  According to the specification, the EVSE corrects the raw measurements found in **CM_ATTEN_PROFILE.IND** by subtracting the insertion loss (AttnRxEVSE) of its receive path before folding the data into **CM_ATTEN_CHAR.IND**.  
- **Impact on Final Attenuation Values**  
  This correction ensures the EV sees the “true” attenuation from M-SOUNDS, compensating for any internal EVSE losses (e.g., transformers, lines, or coupling components).

## 4. Integration in the SLAC Flow
1. **Sequence of Messages**  
   1. **CM_START_ATTEN_CHAR.IND / M-SOUNDS**: The EV broadcasts M-SOUNDS, and the EVSE measures the signal for each.  
   2. **CM_ATTEN_PROFILE.IND**: The EVSE (internally) aggregates or stores the raw attenuation for each M-SOUND in these messages.  
   3. **CM_ATTEN_CHAR.IND**: Once all M-SOUNDS are processed, the EVSE applies arithmetic averaging and AttnRxEVSE correction, then sends the final, combined attenuation data to the EV.

2. **Output to the EV**  
   The end result of these intermediate **CM_ATTEN_PROFILE.IND** messages is an averaged attenuation profile that appears in **CM_ATTEN_CHAR.IND** for the EV to evaluate which EVSE is best matched.

## 5. Summary
- **CM_ATTEN_PROFILE.IND** contains per‐M-SOUND attenuation measurements as part of SLAC’s signal strength measurement.  
- The EVSE corrects and averages these measurement values before generating the final **CM_ATTEN_CHAR.IND** message that is sent to the EV.  
- This process allows the EV to accurately identify which EVSE node is directly connected, based on corrected and averaged attenuation data.

================================================================================

Question: What is CM_VALIDATE.REQ?

Answer: ## 1. Overview
**CM_VALIDATE.REQ** is a message used during the *validation process* of the SLAC matching procedure. It is sent by the EV (Electric Vehicle) to the EVSE (Electric Vehicle Supply Equipment) to either:
- Begin an initial validation handshake (first request-response or “step 1”), or  
- Initiate a BCB-Toggle sequence (second request-response or “step 2”).  

The primary purpose of **CM_VALIDATE.REQ** is to confirm that the EV is truly connected to the correct EVSE (i.e., the one discovered and selected during the SLAC signal strength measurement).

## 2. Role in the Validation Process
1. **Two-Part Validation**  
   The validation phase is divided into two parts, each part consisting of a **CM_VALIDATE.REQ** message and a corresponding **CM_VALIDATE.CNF** reply.  
   - **Step 1:** Checks if the EVSE is *ready*, *not ready*, *not required*, or *unable* to proceed with validation.  
   - **Step 2:** Involves the actual BCB-Toggle counting on the EV side, with the EVSE measuring how many toggles occur and reporting the result.

2. **When Used**  
   - After completing SLAC signal strength measurement (which may conclude with an “EVSE_POTENTIALLY_FOUND” status).  
   - If the EV desires an additional, independent verification of the physical connection over the control pilot line.

## 3. Message Fields and Definitions
According to **Table A.5** and **Table A.6** (for first and second request-response), **CM_VALIDATE.REQ** has the following fields:

1. **Signal Type (Octet 0)**  
   - Always set to **0x00**, indicating “PEV S2 toggles on control pilot line.”

2. **Timer (Octet 1)**  
   - **In the first request-response** (“step 1”): fixed to **0x00** (meaning zero).  
   - **In the second request-response** (“step 2”): variable (e.g., 0x00 = 100 ms, 0x01 = 200 ms), defining how long the EVSE listens for BCB-Toggles.

3. **Result (Octet 2)**  
   - **In the first request-response** (“step 1”): fixed to **0x01** = “ready,” which signals that the EV is ready to start a validation process.  
   - **In the second request-response** (“step 2”): also **0x01** = “ready,” indicating the EV is about to perform BCB-Toggles.

Any **CM_VALIDATE.REQ** containing a field value outside the valid definitions in **Table A.5** or **Table A.6** is considered invalid and shall be ignored.

## 4. Usage and Sequence Details
### 4.1 Step 1: Initial Request-Response
- The EV sends a **CM_VALIDATE.REQ** (Timer = 0x00, Result = 0x01) to see if the EVSE can perform validation.  
- The EVSE answers with **CM_VALIDATE.CNF** indicating:  
  - **Ready** (0x01) – EVSE is prepared for validation.  
  - **Not Ready** (0x00) – EVSE is busy; EV can retry or move on.  
  - **Not Required** (0x04) – EVSE suggests validation is unnecessary.  
  - **Failure** (0x03) – EVSE does not support validation.

### 4.2 Step 2: BCB-Toggle Request-Response
- If the EVSE responded **Ready**, the EV proceeds to the second **CM_VALIDATE.REQ** with a nonzero Timer, telling the EVSE how long it will toggle the control pilot line (BCB-Toggle sequence).  
- After sending **CM_VALIDATE.REQ** (Timer != 0x00, Result = 0x01), the EV performs the toggling.  
- The EVSE counts the toggles for the specified duration and replies with **CM_VALIDATE.CNF**, typically:
  - **Success** (0x02) – Toggling finished successfully, and the EVSE includes the count of toggles seen.  
  - **Failure** (0x03) – Toggling couldn’t be measured validly or EVSE can’t complete it.

## 5. Important Constraints
1. **Invalid Content**  
   Any **CM_VALIDATE.REQ** with fields deviating from the definitions in Table A.5 and Table A.6 is ignored by the receiver.  
2. **Result Field**  
   - If the EVSE sees a **CM_VALIDATE.REQ** with a *Result* other than “ready,” the validation fails.  
3. **Timing Requirements**  
   - The EV starts *TT_match_response* upon sending **CM_VALIDATE.REQ** and waits for the EVSE’s **CM_VALIDATE.CNF**.  
   - If no valid **CM_VALIDATE.CNF** arrives within *TT_match_response*, the EV retries or deems the validation process failed for that EVSE.

## 6. Summary
**CM_VALIDATE.REQ** is the EV’s message initiating or continuing the validation process to confirm an accurate SLAC matching decision. Through:
- **Step 1**: Checking whether the EVSE can handle validation.  
- **Step 2**: Actually executing a BCB-Toggle sequence measured by the EVSE.  

The **CM_VALIDATE.REQ** message ensures both sides coordinate and confirm the physical EV-EVSE link beyond the signal strength measurement phase.

================================================================================

Question: What is CM_VALIDATE.CNF?

Answer: ## 1. Overview
**CM_VALIDATE.CNF** is the response message used in the *validation process* of the SLAC matching procedure. This validation process ensures the EV (Electric Vehicle) and the EVSE (Electric Vehicle Supply Equipment) correctly identify each other beyond the initial signal strength measurement. **CM_VALIDATE.CNF** is sent by the EVSE to the EV in reply to a **CM_VALIDATE.REQ** message and can appear in either “step 1” (first request-response) or “step 2” (second request-response) of the validation process. Its main purpose is to inform the EV about the EVSE’s current validation status, including whether the EVSE is ready, not ready, or has completed the BCB-Toggle counting successfully.

---

## 2. Role in the Validation Process
1. **Two-Part Validation**  
   The validation phase consists of two parts (each part is a request-response pair):  
   - **Step 1:** The EV queries the EVSE to see if it can proceed with validation. The EVSE replies with **CM_VALIDATE.CNF** indicating states such as *ready*, *not ready*, *not required*, or *failure*.  
   - **Step 2:** If the EVSE is ready, the EV performs BCB-Toggles on the control pilot line, while the EVSE counts those toggles. After this counting, the EVSE issues **CM_VALIDATE.CNF** again, typically to report *success* (including the toggle count) or *failure*.

2. **When Used**  
   - **Step 1**: Confirms whether the EVSE is able (or willing) to conduct the validation process.  
   - **Step 2**: Concludes with the EVSE providing the BCB-Toggle count and the final outcome of the validation.

---

## 3. Message Fields
**CM_VALIDATE.CNF** is specified differently for the first and second request-response, based on **Table A.5** (step 1) and **Table A.6** (step 2). Key fields include:

1. **SignalType (Octet 0)**
   - Fixed at **0x00**, indicating “PEV S2 toggles on control pilot line.”

2. **ToggleNum (Octet 1)**
   - **Step 1**: Always **0x00** because no toggles are counted yet.  
   - **Step 2**: Contains the number of BCB-Toggles the EVSE detected within the time window.

3. **Result (Octet 2)**
   - Can be one of:
     - **0x00** = “Not Ready” (the EVSE is busy or not currently able to validate)
     - **0x01** = “Ready” (the EVSE is prepared to continue)
     - **0x02** = “Success” (BCB-Toggle counting completed successfully)
     - **0x03** = “Failure” (the EVSE either cannot perform validation or encountered an error)
     - **0x04** = “Not Required” (the EVSE advises that validation might not be necessary)

Any content deviating from these definitions is considered invalid.

---

## 4. Behavior and Usage Details
### 4.1 First Request-Response (Step 1)
1. **EV’s CM_VALIDATE.REQ** arrives with Timer = 0 and Result = “ready”.  
2. **EVSE’s CM_VALIDATE.CNF** responds with:  
   - **Ready (0x01)** – EVSE is prepared for further validation (step 2).  
   - **Not Ready (0x00)** – EVSE is occupied; EV might retry later.  
   - **Not Required (0x04)** – EVSE suggests that validation can be skipped.  
   - **Failure (0x03)** – EVSE does not support (or cannot do) validation.  
   - **Success (0x02)** is **not** used during step 1.

### 4.2 Second Request-Response (Step 2)
1. **EV’s CM_VALIDATE.REQ** indicates the intended Timer and “ready” to start BCB-Toggles.  
2. **EVSE’s CM_VALIDATE.CNF** after counting toggles:
   - **Success (0x02)** – BCB-Toggle measurement done successfully; includes the ToggleNum counted.  
   - **Failure (0x03)** – Something went wrong (e.g., invalid data, toggles not counted properly).  
   - **Not Ready (0x00)** or **Not Required (0x04)** can also appear if the EVSE cannot complete or does not require the toggles.

---

## 5. Outcomes and Constraints
1. **Stopping Criteria**  
   - If **CM_VALIDATE.CNF** returns “failure,” “not ready,” or “not required” in step 2, the EV typically moves on to another potential EVSE.  
   - If **CM_VALIDATE.CNF** returns “success,” the EV compares the reported ToggleNum with the toggles it performed.  
2. **Invalid Content**  
   Any **CM_VALIDATE.CNF** whose fields deviate from the standard definitions is ignored by the EV.  
3. **Timeouts and Retries**  
   - The EV or EVSE sets various timers (like *TT_match_response*) to wait for **CM_VALIDATE.CNF** or to resend **CM_VALIDATE.REQ**.  
   - Multiple retries may occur if no valid **CM_VALIDATE.CNF** is received.

---

## 6. Summary
**CM_VALIDATE.CNF** is the EVSE’s response within the validation process, telling the EV whether the EVSE:
- Is ready or not to validate (step 1),
- Has counted toggles successfully or encountered a failure (step 2),
- Or indicates that validation is not required.

This message provides the EV with a clear outcome to either proceed, retry, or move on in the overall SLAC matching decision process.

================================================================================

Question: What is CM_SLAC_MATCH.REQ?

Answer: ## 1. Overview
**CM_SLAC_MATCH.REQ** is a unicast message sent by the EV (Electric Vehicle) to the EVSE (Electric Vehicle Supply Equipment) once the EV has determined (through signal strength measurement, optional validation, etc.) that a specific EVSE is the correct counterpart. This request finalizes the matching phase by initiating the logical network parameter exchange, leading to the confirmation of a valid communications link for subsequent higher-level data exchange.

---

## 2. Purpose and Role
1. **Finalizing the Matching Process**  
   After the EV has run SLAC (signal strength measurement) and optionally performed a validation step (e.g., BCB-Toggle in the validation process), it issues **CM_SLAC_MATCH.REQ** to inform the EVSE that it has selected this EVSE and wishes to finalize the link setup.

2. **Logical Network Parameter Exchange**  
   The **CM_SLAC_MATCH.REQ** triggers the EVSE to respond with **CM_SLAC_MATCH.CNF**, providing the EV with the logical network parameters (such as the NMK, NID) required to join the HomePlug Green PHY network for ongoing communication.

---

## 3. Message Definition
### 3.1 Fields (Per Table A.7)
**CM_SLAC_MATCH.REQ** includes the following core fields:

- **APPLICATION_TYPE** (Octet 0)  
  \- Fixed value (0x00) indicating *PEV–EVSE matching*.

- **SECURITY_TYPE** (Octet 1)  
  \- Fixed value (0x00) indicating *No Security*.

- **MVFLength** (Octets 2 to 3)  
  \- Contains a fixed value for matching (e.g., 0x3e).

- **PEV ID** (Octets 4 to 21)  
  \- 17 bytes (often 0x00 if not used). This field is reserved for the EV’s unique ID if applicable.

- **PEV MAC** (Octets 21 to 26)  
  \- 6 bytes containing the MAC address of the EV’s Host (i.e., the EV’s low-layer communication module).

- **EVSE ID** (Octets 26 to 43)  
  \- 17 bytes (often 0x00 if not used). This field is reserved for the EVSE’s unique ID if applicable.

- **EVSE MAC** (Octets 44 to 49)  
  \- 6 bytes containing the EVSE’s MAC address (optional to fill if known by the EV).

- **RunID** (Octets 50 to 57)  
  \- 8 bytes used to match the ongoing SLAC session. It must be the same RunID the EV previously used in the parameter exchange messages (e.g., CM_SLAC_PARM.REQ).

- **RSVD** (Octets 58 to 65)  
  \- 8 bytes reserved (0x00).

Any deviation from these definitions is considered invalid content, leading the EVSE to ignore the message.

---

## 4. Process Flow
1. **Prerequisite Steps**  
   - The EV has identified an EVSE either as *EVSE_FOUND* or has completed additional checks (e.g., validation).  
   - Timers such as **TT_EVSE_match_session** are running on the EVSE side, waiting for either **CM_VALIDATE.REQ** or **CM_SLAC_MATCH.REQ**.

2. **EV Sending CM_SLAC_MATCH.REQ**  
   - The EV forms and sends **CM_SLAC_MATCH.REQ** unicast to the EVSE’s MAC address.  
   - This informs the EVSE that the EV has chosen the EVSE for the final link setup.

3. **EVSE Response**  
   - The EVSE, upon receiving a valid **CM_SLAC_MATCH.REQ**, replies with **CM_SLAC_MATCH.CNF** within **TP_match_response** time.  
   - If the request is invalid (fields outside the specification), the EVSE ignores it.

4. **Retries**  
   - If the EV does not receive **CM_SLAC_MATCH.CNF**, it may resend **CM_SLAC_MATCH.REQ** (similar to other SLAC retries).  
   - The EVSE, upon receiving duplicate **CM_SLAC_MATCH.REQ**, must respond again.

---

## 5. Key Constraints and Error Handling
1. **Invalid Content**  
   If **CM_SLAC_MATCH.REQ** deviates from the format in Table A.7 (e.g., wrong field sizes or mismatched RunID), the EVSE ignores it.

2. **Timeouts**  
   - **TT_EVSE_match_session**: The EVSE expects *some* request (either a validation request or **CM_SLAC_MATCH.REQ**) before this timer expires. Otherwise, the matching is considered **FAILED**.  
   - **TP_match_response**: The EVSE must respond with **CM_SLAC_MATCH.CNF** within this time.

3. **Successful Conclusion**  
   Once the EV receives **CM_SLAC_MATCH.CNF**, the link is formally established on the PLC layer, with final parameters (NMK, NID) enabling stable communication.

---

## 6. Summary
**CM_SLAC_MATCH.REQ** is the EV’s concluding message in the SLAC matching process. It confirms that the EV has decided to proceed with the chosen EVSE, prompting the EVSE to provide final network parameters. Properly formatted and timed according to Table A.7, this request transitions the system from matching/validation to a fully joined logical network, completing the lower-layer setup for subsequent power-line communication sessions.

================================================================================

Question: What is CM_SLAC_MATCH.CNF?

Answer: ## 1. Overview
**CM_SLAC_MATCH.CNF** is a unicast confirmation message sent by the EVSE (Electric Vehicle Supply Equipment) to the EV (Electric Vehicle) in response to a **CM_SLAC_MATCH.REQ**. It finalizes the logical network parameter exchange phase of the SLAC matching process by providing the EV with crucial network parameters (like the Network Membership Key (NMK) and Network ID (NID)), enabling the EV to join the EVSE’s HomePlug Green PHY network for subsequent communication.

---

## 2. Purpose and Role
1. **Concluding the Matching Process**  
   After the EV has decided on a specific EVSE (via signal strength and possible validation steps), it sends a **CM_SLAC_MATCH.REQ**. The EVSE replies with **CM_SLAC_MATCH.CNF**, delivering final link parameters.

2. **Providing Network Credentials**  
   The **CM_SLAC_MATCH.CNF** message contains fields such as the NMK and NID, which the EV uses to configure its power line communication interface (e.g., via `CM_SET_KEY.REQ`) for secure and stable data exchange.

3. **Ensuring Timely Link Setup**  
   The EV expects **CM_SLAC_MATCH.CNF** within a defined response timer. Upon receiving it, the EV has up to **TT_match_join** time to establish the link. If no link is formed, the matching process is considered **FAILED**.

---

## 3. Message Definition
According to **Table A.7**, the **CM_SLAC_MATCH.CNF** message contains specific fields for the final network parameter exchange. Key fields include:

- **APPLICATION_TYPE** (Octet 0)  
  \- Fixed value (0x00) indicating “PEV–EVSE matching.”

- **SECURITY_TYPE** (Octet 1)  
  \- Fixed value (0x00) indicating “No Security.”

- **MVFLength** (Octets 2–3)  
  \- For **CM_SLAC_MATCH.CNF**, this is set to 0x56.

- **PEV ID** (Octets 4–20) and **PEV MAC** (Octets 21–26)  
  \- (Typically zero or reserved for the EV’s info.)

- **EVSE ID** (Octets 27–43) and **EVSE MAC** (Octets 44–49)  
  \- (Typically zero or reserved for the EVSE’s info.)

- **RunID** (Octets 50–57)  
  \- 8-byte identifier matching that used in previous SLAC steps (e.g., CM_SLAC_PARM.REQ).

- **RSVD** (Octets 58–65)  
  \- 8 bytes reserved at 0x00.

- **NID** (Octets 66–72)  
  \- 7 bytes specifying the network ID derived by the EVSE.

- **RSVD** (Octet 73)  
  \- 1 byte reserved at 0x00.

- **NMK** (Octets 74–89)  
  \- 16-byte private NMK used by the EVSE.

Any deviation from these definitions is invalid, and an EV ignoring an invalid CNF may conclude the matching process as **FAILED**.

---

## 4. Process Flow
1. **EV’s Request**: The EV sends **CM_SLAC_MATCH.REQ** to the EVSE, signifying it wants final network parameters.
2. **EVSE Response**:  
   - The EVSE transmits **CM_SLAC_MATCH.CNF** containing the *NID*, *NMK*, and other fields within **TP_match_response**.  
   - If the EVSE sees repeated requests, it must resend the same confirmation each time.
3. **EV Configuration**:  
   - Upon receiving **CM_SLAC_MATCH.CNF**, the EV typically configures its modem with the NMK (e.g., via `CM_SET_KEY.REQ`).  
   - The EV then attempts to join the EVSE’s network.  
4. **Link Completion**:  
   - The EV must complete link establishment within **TT_match_join** after receiving **CM_SLAC_MATCH.CNF**.  
   - Failing that, the EV deems the matching process **FAILED**.

---

## 5. Key Constraints and Error Handling
1. **Invalid Content**  
   If **CM_SLAC_MATCH.CNF** does not match Table A.7 specifications (e.g., incorrect RunID or field sizes), the EV should ignore it.

2. **Timeouts**  
   - **TP_match_response** ensures the EVSE responds quickly to the EV’s match request.  
   - **TT_match_join** enforces a limit for successful link formation after the CNF is received.

3. **Post-Processing**  
   - The EV uses the NMK and NID from **CM_SLAC_MATCH.CNF** to finalize communication parameters.  
   - If this final step or link formation fails, the entire matching process may be retried or marked **FAILED**.

---

## 6. Summary
**CM_SLAC_MATCH.CNF** is the EVSE’s unicast response containing essential logical network credentials (NMK/NID) and completing the SLAC matching phase. Once the EV obtains these parameters and successfully joins the network, the physical and data link layers are fully established, allowing further communication.

================================================================================

Question: What is CM_SET_KEY.REQ?

Answer: ## 1. Overview
**CM_SET_KEY.REQ** is a unicast message sent by a device (such as an EVSE or EV) to its own local low-layer communication module. Its primary purpose is to configure the local power line communication node with a Network Membership Key (NMK) and Network ID (NID), enabling or updating membership in a specified HomePlug Green PHY logical network.

---

## 2. Purpose and Usage
1. **Joining the Logical Network**  
   After the matching process, an EVSE or EV typically needs to apply a newly provided NMK and NID. This is done by sending **CM_SET_KEY.REQ** to the local communication module. For example, an EVSE will configure itself with the NMK and NID from a previously sent CM_SLAC_MATCH.CNF.

2. **Timing of the Configuration**  
   - The EVSE can issue **CM_SET_KEY.REQ** immediately after sending CM_SLAC_MATCH.CNF or any time before (if it knows the NID/NMK in advance).  
   - This ensures that the device is ready to form or maintain a link with an EV using those credentials.

3. **Ensuring Valid Network Parameters**  
   The message explicitly sets the parameters so that the local station can recognize and participate in the correct logical network once the EV attempts to join.

---

## 3. Message Structure (Table A.8)
**CM_SET_KEY.REQ** has specific fields, each occupying predefined octets. The key fields include:

1. **Key Type** (Octet 0)  
   - Fixed value `0x01`, indicating the key type is “NMK.”
2. **My Nonce** (Octets 1–4)  
   - Fixed value `0x00000000` (encrypted payload not used).
3. **Your Nonce** (Octets 5–8)  
   - Fixed value `0x00000000` (encrypted payload not used).
4. **PID** (Octet 9)  
   - `0x04`, indicating “HLE protocol.”
5. **PRN** (Octets 10–11)  
   - Fixed value `0x0000` (encrypted payload not used).
6. **PMN** (Octet 12)  
   - Fixed value `0x00` (encrypted payload not used).
7. **CCo Capability** (Octet 13)  
   - A variable value that reflects the station’s capability (e.g., whether it can serve as a Central Coordinator).
8. **NID** (Octets 14–20)  
   - 7 bytes containing the Network ID, where 54 bits represent the NID and the top 2 bits are `0b00`.
9. **NewEKS** (Octet 21)  
   - `0x01`, indicating the NMK is to be updated.
10. **NewKey** (Octets 22–37)  
   - 16-byte NMK value that the local station should apply for network membership.

---

## 4. Implementation Details
1. **Local Configuration**  
   - **CM_SET_KEY.REQ** is always a unicast command to the local station.  
   - It must be invoked whenever the station needs to update or confirm the NMK and NID to reflect new network membership.

2. **EVSE Example**  
   - After sending the NMK and NID in a CM_SLAC_MATCH.CNF, the EVSE uses **CM_SET_KEY.REQ** to ensure its internal communication module is set accordingly.  
   - This might happen before or after sending the CNF, but must be done at the latest immediately after sending CM_SLAC_MATCH.CNF.

3. **No Encrypted Payload**  
   - Several fields (e.g., `My Nonce`, `Your Nonce`, `PRN`, `PMN`) are set to zero because encryption is not used in this context.

---

## 5. Summary
**CM_SET_KEY.REQ** is the essential command for applying new logical network credentials (NMK/NID) on the local HomePlug Green PHY node. By populating its fixed and variable fields according to Table A.8, a device (EV or EVSE) ensures proper network alignment and finalizes the process of joining or updating membership in a HomePlug Green PHY logical network.

================================================================================

Question: What is CM_SET_KEY.CNF?

Answer: ## 1. Overview
**CM_SET_KEY.CNF** is the confirmation message corresponding to a **CM_SET_KEY.REQ** in the HomePlug Green PHY communication process. It indicates whether the low-layer communication module successfully applied the network configuration parameters (such as the NMK and NID) sent by the request.

---

## 2. Purpose and Usage
1. **Confirmation of Key Setting**  
   - After the local communication module (on an EV or EVSE) receives a **CM_SET_KEY.REQ**, it may respond with **CM_SET_KEY.CNF** to signal success or failure in setting the parameters.
  
2. **Implementation-Specific Handling**  
   - The standard notes that “it is up to the implementation how to handle a negative response in a CM_SET_KEY.CNF or a missing CM_SET_KEY.CNF at all.” This means the details of error handling or retry logic vary among different implementations.

3. **Relation to Logical Network Joining**  
   - **CM_SET_KEY.CNF** typically follows an attempt to set the NMK (Network Membership Key) and NID (Network ID) during the joining process of a logical network. If the key is correctly applied, the station can proceed to join the network.

---

## 3. Related Primitives and Process
- **CM_SET_KEY.REQ**: Requests the low-layer module to set a new NMK and other relevant parameters.  
- **CM_SET_KEY.CNF**: The module’s response to confirm whether these parameters were set successfully or not.  
- **Joining the Logical Network**: Performed once the matching process determines an EVSE is “EVSE_FOUND.” The EV or EVSE finalizes network membership parameters (NMK, NID) and may wait for **CM_SET_KEY.CNF** to confirm success.

---

## 4. Implementation Details
1. **Positive or Negative Responses**  
   - A successful **CM_SET_KEY.CNF** generally indicates the new NMK and NID are applied, allowing the device to participate fully in the logical network.  
   - A negative response, or no response at all, leaves it “up to the implementation” to decide on fallback strategies or retries.

2. **When the Response Is Missing**  
   - The specification explicitly allows that **CM_SET_KEY.CNF** might not arrive. An implementation must define how to proceed or retry in such a scenario.

3. **EV and EVSE Perspective**  
   - EVSE Side: May send and then expect a **CM_SET_KEY.CNF** from its own local communication module after configuring itself with new network parameters.  
   - EV Side: Would likewise handle the response from its local module in the event it changes or confirms network membership parameters.

---

## 5. Summary
**CM_SET_KEY.CNF** is the message that confirms the result of a **CM_SET_KEY.REQ**. Its handling—especially in the case of a negative or missing response—is not strictly defined by the standard, giving manufacturers latitude in designing error handling or retry behaviors. This flexibility means each implementation decides how to proceed if **CM_SET_KEY.CNF** indicates failure or is never received.
================================================================================

Question: What is CM_AMP_MAP.REQ?

Answer: ## 1. Overview
**CM_AMP_MAP.REQ** is a management message entry (**MME**) used in the HomePlug Green PHY communication process (the “amplitude map exchange” stage) to request specific transmission power settings for individual carriers. This MME can have two different functions, depending on whether it is sent to the local low-layer communication module or sent from one host to a remote host:

1. **Local Command**  
   When sent by the host (EV or EVSE) to its own local low-layer communication module, **CM_AMP_MAP.REQ** instructs the local module to modify its transmission power for specified carriers.

2. **Remote Command**  
   When sent from one host (e.g., an EV) to another host (e.g., an EVSE) through the low-layer communication, it only conveys the requested per-carrier power settings. In this scenario, it does **not** directly affect the sender’s low-layer communication module but provides the remote side with information for its own amplitude map calculation.

Either way, this request is confirmed by a **CM_AMP_MAP.CNF** message, which indicates success or failure (and possibly additional details needed for completing the amplitude map exchange).

---

## 2. Purpose and Usage

### 2.1 Power Limitation Request
The amplitude map exchange is an **optional** function enabling an EV or EVSE to request a counterpart device to reduce transmission power on certain carriers. For instance, the EVSE can request the EV to notch or limit power on specific carriers to comply with local regulations or reduce interference on certain frequencies.

### 2.2 Interaction with CM_AMP_MAP.CNF
After a **CM_AMP_MAP.REQ** is sent:

- The counterpart low-layer communication module (or the local one, if the request is internal) assesses the requested amplitude map changes.
- It then replies with **CM_AMP_MAP.CNF** to confirm whether the request was valid and can be implemented successfully.

If **CM_AMP_MAP.REQ** is invalid or not supported, it can be ignored or result in an error indication.

### 2.3 Relation to PSD Reference
All amplitude/power values in **CM_AMP_MAP.REQ** are referenced to −50 dBm/Hz, and data is specified in steps of 2 dB. For example, a raw amplitude map data value (`AMDATA`) of `0xE` (decimal 14) indicates a −28 dB difference from the −50 dBm/Hz reference.

---

## 3. Key Fields in CM_AMP_MAP.REQ
According to Table A.9 (MMEs parameters definition for amplitude map exchange):

- **AMLEN (Octets 0–1)**: A fixed value indicating the number of carriers used. For example, `0x3A` can mean 58 carriers are included.
- **AMDATA[n]**:
  - Each carrier’s requested power adjustment is represented in 4-bit segments.
  - Consecutive 4-bit fields map to consecutive carriers, telling how much to reduce the power from the −50 dBm/Hz reference.

Thus, **CM_AMP_MAP.REQ** consists of:
1. **AMLEN** — a 2-octet field specifying how many carriers are in the request.
2. **AMDATA** — an array of 4-bit entries that describe the power offset per carrier.

---

## 4. Example Use Case
1. **EVSE wants the EV to reduce power**  
   - The EVSE sends `CM_AMP_MAP.REQ` with amplitude map data (e.g., carriers 2 and 3 require a lower power to −78 dBm/Hz).
2. **EV Compares to Default PSD**  
   - The EV checks each carrier’s current power setting (its default PSD at the socket) and calculates how much additional reduction is needed.
3. **EV Confirms**  
   - The EV answers with `CM_AMP_MAP.CNF` to confirm it will apply (or attempt to apply) the requested changes, or to indicate failure.
4. **EV Applies to Local Module**  
   - To effect the changes on its own transmitter, the EV might subsequently issue a local `CM_AMP_MAP.REQ` to configure its own low-layer communication module accordingly.

---

## 5. Additional Considerations

1. **Invalid Content Handling**  
   If **CM_AMP_MAP.REQ** contains content deviating from Table A.9, the receiver should ignore it as invalid.

2. **Timeouts and Retries**  
   - If no `CM_AMP_MAP.CNF` arrives within the maximum waiting time (`TT_match_response`), the sender can retransmit up to `C_EV_match_retry` times.
   - Failure to receive a valid confirmation after all retries implies the matching (or amplitude map exchange) is considered FAILED.

3. **Optionality**  
   The amplitude map exchange is **not mandatory** in all implementations. If neither the EV nor the EVSE initiates this step, a default amplitude map remains in use.

---

## 6. Summary
**CM_AMP_MAP.REQ** is the amplitude map exchange request MME that allows an EV or EVSE to propose or apply changes in transmission power on a carrier-by-carrier basis, always referenced to −50 dBm/Hz. Depending on whether it is targeted to the local module or a remote host, **CM_AMP_MAP.REQ** either directly modifies local power settings or communicates requested amplitude adjustments. The amplitude map exchange concludes once a corresponding **CM_AMP_MAP.CNF** is received.

================================================================================

Question: What is CM_AMP_MAP.CNF?

Answer: ## 1. Overview
**CM_AMP_MAP.CNF** is the confirmation message sent in response to a **CM_AMP_MAP.REQ** message during the amplitude map exchange process in HomePlug Green PHY communication. Its primary purpose is to indicate whether a device successfully accepts and applies (or rejects) the requested amplitude-map settings for transmission power per carrier.

---

## 2. Related Context

### 2.1 Amplitude Map Exchange
- The amplitude map exchange is an *optional* step that allows an EV (Electric Vehicle) or EVSE (Electric Vehicle Supply Equipment) to request the other device to **reduce transmission power** on selected carriers.
- **CM_AMP_MAP.REQ** is the message that initiates this process, specifying desired power offsets for certain carriers (related to a −50 dBm/Hz reference).
- **CM_AMP_MAP.CNF** is the mandatory response confirming or denying the requested amplitude-map changes.

### 2.2 Relationship to CM_AMP_MAP.REQ
- After receiving **CM_AMP_MAP.REQ**, the requested node evaluates the proposed power-limit values.
- It then replies with **CM_AMP_MAP.CNF**:
  - If the request is valid, the node sets the **CM_AMP_MAP.CNF** to indicate success (0x00) or failure (0x01), or potentially another reserved code.
  - If the request is invalid (deviates from Table A.9 definitions), it is ignored, and no valid confirmation is generated.

---

## 3. Key Fields of CM_AMP_MAP.CNF

According to **Table A.9** (MMEs parameters definition for amplitude map exchange):

1. **ResType** (Octet 0):  
   - 1 octet field  
   - Contains the result code:  
     - 0x00 = success  
     - 0x01 = failure  
     - 0x02 – 0xFF = reserved  

These codes signify whether the node has successfully processed the amplitude map request or encountered an error (e.g., out-of-range values).

---

## 4. Usage and Behavior

1. **Transmission Power Coordination**  
   - When a device (EV or EVSE) sends **CM_AMP_MAP.REQ**, it expects a **CM_AMP_MAP.CNF** within a performance time (e.g., **TP_match_response**).  
   - If **CM_AMP_MAP.CNF** is not received in time, or the content is invalid, the process may be retried or considered failed.

2. **Invalid Content Handling**  
   - If **CM_AMP_MAP.CNF** contains invalid content (i.e., fields not aligning with Table A.9), the receiver ignores it according to the specification.

3. **Retried Requests**  
   - If the node sending **CM_AMP_MAP.REQ** does not receive **CM_AMP_MAP.CNF**, it may retransmit the request.  
   - In such a case, the receiving node must respond again (even if it previously sent a confirmation that was lost).

---

## 5. Summary
**CM_AMP_MAP.CNF** is the unicast confirmation message that concludes an amplitude map exchange request (**CM_AMP_MAP.REQ**). It informs whether the request was processed successfully (0x00) or resulted in failure (0x01), using a 1-octet field called “ResType.” This mechanism ensures EVs and EVSEs can coordinate fine-tuned carrier power levels to meet local regulatory or system requirements.

================================================================================

Question: What is D-LINK_READY.indication?

Answer: ## 1. Overview
**D-LINK_READY.indication** is a primitive used to inform higher layers (HLE) about any **change** in the status of the data link. It can signal either:
- **“link established”** or 
- **“no link.”**

This primitive is sent whenever the communication link transitions between these two states, ensuring higher layers remain informed of the link’s current availability.

---

## 2. Related Context

### 2.1 Purpose of D-LINK_READY.indication
- **Notifies HLE** when a data link is established or lost.
- **Triggers** with any link status change:
  - **Link Established**: For example, after the matching process successfully completes.
  - **No Link**: If the link is lost or intentionally terminated.

### 2.2 Usage Within the Matching Process
1. **Link Established**  
   - Once an EV and an EVSE enter the “Matched” state, the communication node reports the successful link setup to higher layers using **D-LINK_READY.indication(link established).**  
   - According to the specification, “Any transition from the state ‘Matching’ triggers a call of the primitive D-LINK_READY.indication to indicate a successful or failed data-link setup.”

2. **Link Lost**  
   - If the data link is lost for any reason after being established, **D-LINK_READY.indication(no link)** is sent to inform higher layers.  
   - This might occur due to control pilot loss, a request from HLE to terminate, or any communication error that effectively severs the link.

### 2.3 Examples of Trigger Events
- **Wake-up scenario**: As soon as lower layers detect a new data link after waking up from a low-power state, they send **D-LINK_READY.indication(link established)** to HLE.  
- **Leaving the logical network**: When a low-layer communication module leaves the network, the status changes from “Matched” to “Unmatched,” triggering **D-LINK_READY.indication(no link).**

---

## 3. Primitive Details

Based on **Table 4 — D-LINK_READY.indication primitive**, the parameters and description are as follows:

| **Primitive**             | **D-LINK_READY.indication** |
|---------------------------|-----------------------------|
| **Entity to support**     | EV, EVSE                   |
| **Parameter name**        | D-LINKSTATUS               |
| **Description**           | Status of communication link:<br>— *no link*<br>— *link established* |

- **D-LINKSTATUS** indicates whether the data link is currently established or not.

---

## 4. Summary

- **D-LINK_READY.indication** is a core notification mechanism for higher layers, signaling any shift between “link established” and “no link.”  
- It ensures the system responds appropriately to newly formed connections (e.g., after successful matching) or to lost connections (e.g., on control pilot drop or network exit).  
- This primitive underpins overall link coordination and keeps the HLE updated on the real-time status of the low-layer data link.

================================================================================

Question: What is D-LINK_TERMINATE.request?

Answer: ## 1. Overview
The **D-LINK_TERMINATE.request** is a command primitive used by higher-layer entities (HLE) to instruct the lower layers to **terminate** the existing data link. Once this request is received, the communication node or low-layer communication module **leaves** the logical network and resets its link parameters to a default or “Unmatched” state.

---

## 2. Related Context

### 2.1 Triggering Condition and Effects
- **Issued by HLE**: The higher-level application layer sends D-LINK_TERMINATE.request to end the data link.
- **Leaving the Network**: Upon receiving this request:
  - The low-layer communication module **leaves** the logical network.
  - It **resets** all link-related parameters (such as the NMK for HomePlug Green PHY).
  - The node state moves from “Matched” back to “Unmatched.”

### 2.2 Timing Constraints
- **TP_match_leave**: When the node receives D-LINK_TERMINATE.request, it must leave the logical network within the defined performance time \(TP_match_leave\).

---

## 3. Primitive Details

According to **Table 5 — D-LINK_TERMINATE.request primitive**, the parameters are:

| **Primitive**              | **D-LINK_TERMINATE.request** |
|----------------------------|------------------------------|
| **Entity to support**      | EV, EVSE                    |

- **Usage**:
  - Instructs lower layers to **terminate** the data link.
  - Can be invoked by either the EV or the EVSE side.

---

## 4. Examples and Process

1. **Request from HLE**  
   - Higher layers decide to end the current communication session for various reasons (e.g., successful session completion, system error, or user-driven action).
   - HLE sends **D-LINK_TERMINATE.request** to the low-layer communication module.

2. **Leaving Logical Network**  
   - Once the low-layer module receives the command, it **disconnects** from the logical network (unjoins).
   - All relevant parameters (e.g., security keys, link states) are reset.
   - The node’s state reverts to **“Unmatched”**, indicating no active data link.

3. **Return to Default**  
   - After termination, the communication node stands ready for any future matching processes or new link establishment.

---

## 5. Summary

- **D-LINK_TERMINATE.request** is a top-level command that **shuts down** the current data link, ensuring the node returns to the “Unmatched” state.  
- This mechanism cleanly **resets** communication parameters and leaves the logical network, facilitating a fresh start for any subsequent matching or link-establishment processes.

================================================================================

Question: What is D-LINK_ERROR.request?

Answer: ## 1. Overview
The **D-LINK_ERROR.request** is a command sent by higher-layer entities (HLE) to the lower layers, instructing them to **terminate** the current data link and **restart** the matching process (including a control pilot transition, typically through state E). It is primarily used in **loss-of-communication** scenarios after a data link has been established and recognized by higher layers.

---

## 2. Related Context

### 2.1 Purpose in Communication Loss
- **Communication Link Lost**: When a data link was already established (and indicated to higher layers) but **fails**, higher layers can invoke D-LINK_ERROR.request to:
  - Terminate the failing data link.
  - **Reinitiate** the matching process (signal strength measurement, control pilot transitions) to restore communication.

### 2.2 Effect on the Matching Process
- **Restart Matching**: Upon receiving D-LINK_ERROR.request, the lower layer transitions to a state (commonly E or F on the control pilot), effectively **resetting** the system from “Matched” or partial states to “Unmatched,” ready to begin a fresh **signal strength measurement** and link negotiation.

---

## 3. Primitive Definition

According to **Table 6 — D-LINK_ERROR.request primitive**, the key points are:

| **Primitive**           | **D-LINK_ERROR.request**                     |
|-------------------------|----------------------------------------------|
| **Entity to support**   | EVSE                                         |
| **Function**            | Terminates data link and restarts matching   |

- **Terminates Data Link**: Immediately ends the current connection at the physical/data link levels.
- **Restart Trigger**: Forces the system to reinitiate matching by transitioning the control pilot to an error state (e.g., state E).

---

## 4. Usage Scenarios and Requirements

1. **Loss of Communication**  
   - If the data link fails after being established, the HLE uses **D-LINK_ERROR.request** to instruct lower layers to **drop** the link and **restart** matching.

2. **State Transitions**  
   - EVSE Side:
     - On receiving D-LINK_ERROR.request, the EVSE’s communication node performs a **control pilot transition** to reinitiate the process (e.g., going from X2 → E/F → X1).
   - EV Side:
     - Similarly, the EV communication node leaves the logical network within the required time (e.g., TP_match_leave), resets the matching state to “Unmatched,” and **awaits** a new matching trigger.

3. **Duty Cycle Options**  
   - Implementation details vary depending on whether the system uses a 5% control pilot duty cycle or nominal duty cycle. In each case, receiving a D-LINK_ERROR.request results in leaving the network and **resetting** states, but the specific transitions (X1, X2, or E/F) can differ.

---

## 5. Summary

- **D-LINK_ERROR.request** is the **error-handling** mechanism used by HLE to **terminate** a defective or lost data link and **force** a restart of the matching process.  
- It ensures the system returns to an “Unmatched” state and attempts a fresh communication setup, preventing the system from remaining in a faulty or partially connected state.

================================================================================

Question: What is D-LINK_PAUSE.request?

Answer: ## 1. Overview
The **D-LINK_PAUSE.request** is a command sent from higher layers (HLE) to the lower layers, instructing them to enter a **power saving mode**. Crucially, even though the lower-layer communication module moves to this low-power or “sleep” mode, the system remains in the **“Matched”** state, preserving the existing logical network configuration for later resumption of active communication.

---

## 2. Related Primitives

### 2.1 D-LINK_PAUSE.request Primitive
According to the specification in Table 7 (from \[V2G3-M12-01\]), the **D-LINK_PAUSE.request** is defined as follows:

- **Function**: Request the lower layers to enter a power saving mode.
- **Behavior**: The “Matched” state is maintained, meaning the system does not discard network or matching information.

---

## 3. Configuration Requirements for Sleep Mode

### 3.1 EV Side
- **Switch to Control Pilot State Bx**  
  Upon receiving **D-LINK_PAUSE.request**, the EV transitions its control pilot to a Bx state and may optionally **unpower** the low-layer communication module.
- **Store Logical Network Parameters**  
  The EV stores the current logical network parameter set. This ensures that upon **waking** from sleep, it can **reuse** the same network configuration.

### 3.2 EVSE Side
- **Switch to Control Pilot State X1**  
  When the EVSE receives **D-LINK_PAUSE.request**, it sets the control pilot to X1 and can place the low-layer communication module in a **low-power** mode.
- **Preserve Network Parameters**  
  Similarly, the EVSE stores the logical network parameter set, so it can quickly **resume** active communication without requiring a full re-matching process.

---

## 4. Sleep Mode Context

1. **Power Saving**  
   A principal use of **D-LINK_PAUSE.request** is to reduce energy consumption by the EV and/or EVSE during periods where active data exchange is unnecessary.  
2. **Maintaining Matched State**  
   Importantly, the session remains **“Matched”**, avoiding a complete breakdown of the communication session. This enables a quick return to an active link without a fresh matching process.

---

## 5. Return from Sleep (Wake-up)

Once in sleep mode, the system can be **awoken** via:

- **Pilot State Transition** (e.g., from Bx or X1 to an active state).
- A **counterpart station’s trigger** (BCB-Toggle or pilot oscillator reactivation).

Upon waking, each party:
- **Reconfigures** to the **last known** logical network parameter set (preserved during sleep).
- **Remains** in the matched state, ready to resume data communication.

---

## 6. Summary

The **D-LINK_PAUSE.request** is a higher-layer instruction that initiates a **sleep/power-saving** mode while preserving the **Matched** state. On receiving this request:
- The **EV** switches its control pilot to Bx and stores network settings.
- The **EVSE** switches its control pilot to X1 and similarly stores network settings.

This allows both sides to **save energy** and later **resume** communication without performing a full re-matching process.

================================================================================

